package testutil

import (
	"bytes"
	"fmt"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"time"

	"veyron.io/tools/lib/collect"
	"veyron.io/tools/lib/util"
)

// methods parses the given signature, which is expected to be
// generated by the "vrpc describe ..." command, extracting the list
// of methods contained in the signature of a veyron RPC server the
// input describes.
func methods(signature string) []string {
	signature = strings.TrimSpace(signature)
	result := []string{}
	lines := strings.Split(signature, "\n")
	for _, line := range lines {
		line = strings.TrimPrefix(line, "func ")
		index := strings.Index(line, "(")
		result = append(result, line[:index])
	}
	sort.Strings(result)
	return result
}

// generateTestSuite generates an xUnit test suite that encapsulates
// the given input.
func generateTestSuite(ctx *util.Context, success bool, pkg string, duration time.Duration, output string) *testSuite {
	// Generate an xUnit test suite describing the result.
	s := testSuite{Name: pkg}
	c := testCase{
		Classname: pkg,
		Name:      "Test",
		Time:      fmt.Sprintf("%.2f", duration.Seconds()),
	}
	if !success {
		fmt.Fprintf(ctx.Stdout(), "%s ... failed\n%v\n", pkg, output)
		f := testFailure{
			Message: "vrpc",
			Data:    output,
		}
		c.Failures = append(c.Failures, f)
		s.Failures++
	} else {
		fmt.Fprintf(ctx.Stdout(), "%s ... ok\n", pkg)
	}
	s.Tests++
	s.Cases = append(s.Cases, c)
	return &s
}

// testProdService test the given production service.
func testProdService(ctx *util.Context, service prodService) (*testSuite, error) {
	root, err := util.VeyronRoot()
	if err != nil {
		return nil, err
	}
	bin := filepath.Join(root, "veyron", "go", "bin", "vrpc")
	var out bytes.Buffer
	opts := ctx.Run().Opts()
	opts.Stdout = &out
	opts.Stderr = &out
	start := time.Now()
	if err := ctx.Run().TimedCommandWithOpts(DefaultTestTimeout, opts, bin, "describe", service.objectName); err != nil {
		return generateTestSuite(ctx, false, service.name, time.Now().Sub(start), out.String()), nil
	}
	if got, want := methods(out.String()), service.signature; !reflect.DeepEqual(got, want) {
		return generateTestSuite(ctx, false, service.name, time.Now().Sub(start), "mismatching signature"), nil
	}
	return generateTestSuite(ctx, true, service.name, time.Now().Sub(start), ""), nil
}

type prodService struct {
	name       string
	objectName string
	signature  []string
}

// VeyronProdServicesTest runs a test of veyron production services.
func VeyronProdServicesTest(ctx *util.Context, testName string) (_ *TestResult, e error) {
	// Initialize the test.
	cleanup, err := initTest(ctx, testName, nil)
	if err != nil {
		return nil, err
	}
	defer collect.Error(func() error { return cleanup() }, &e)

	// Install the vrpc tool.
	if err := ctx.Run().Command("veyron", "go", "install", "veyron.io/veyron/veyron/tools/vrpc"); err != nil {
		return nil, err
	}

	// Describe the test cases.
	namespaceRoot := "/proxy.envyor.com:8101"
	allPassed, suites := true, []testSuite{}
	services := []prodService{
		prodService{
			name:       "mounttable",
			objectName: namespaceRoot,
			signature:  []string{"Mount", "ResolveStep", "ResolveStepX", "Unmount"},
		},
		prodService{
			name:       "application repository",
			objectName: namespaceRoot + "/applicationd",
			signature:  []string{"Match", "Put", "Remove"},
		},
		prodService{
			name:       "binary repository",
			objectName: namespaceRoot + "/binaryd",
			signature:  []string{"Create", "Delete", "Download", "DownloadURL", "Stat", "Upload"},
		},
		prodService{
			name:       "macaroon service",
			objectName: namespaceRoot + "/identity/veyron-test/macaroon",
			signature:  []string{"Bless"},
		},
		prodService{
			name:       "google identity service",
			objectName: namespaceRoot + "/identity/veyron-test/google",
			signature:  []string{"BlessUsingAccessToken"},
		},
		prodService{
			name:       "binary discharger",
			objectName: namespaceRoot + "/identity/veyron-test/discharger",
			signature:  []string{"Discharge"},
		},
	}

	for _, service := range services {
		suite, err := testProdService(ctx, service)
		if err != nil {
			return nil, err
		}
		allPassed = allPassed && (suite.Failures == 0)
		suites = append(suites, *suite)
	}

	// Create the xUnit report.
	if err := createXUnitReport(ctx, testName, suites); err != nil {
		return nil, err
	}
	if !allPassed {
		return &TestResult{Status: TestFailed}, nil
	}
	return &TestResult{Status: TestPassed}, nil
}
